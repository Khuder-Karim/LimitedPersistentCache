*какие части функциональности были реализованы:
============================================

1) Добавление нового слоя (Storage) с указанным лимитом и способом подсчета (по количеству записей, по объёму занятой памяти). 
2) Взятие значения с кеша по ключу. 
3) Добавление пары ключ-значение.
4) Удаление по ключу.
5) Подписка на изменение в кеше.


*Как работает библиотека:
=========================

Кеш состоит из слоев (Storage). Их количество не ограничено. Новые слои добавляются в конец. Добавить можно в любой момент.
get(key), set(key, value), remove(key) - возвращают promise. Если речь идет только о кеше в памяти и в localStorage то никакой работы с асинхронностью нет. Но, я предусмотрел вариант, когда работа со Storage есть асинхронна. Например, storage хранит кеш на вспомогательном сервере, или считывает из файла. Поэтому сделал универсальный интерфейс, который продолжить работать с кешем даже если некоторые его слои (Storage) будут работать асинхронно.
Был создан абстрактный класс для Storage. На основе него были созданы 3 вида Storage: AppStorage, LocalStorage, AsyncStorage. 

AsyncStorage сделан наиболее простым образом. Данные хранятся в памяти, но только при их чтении, записи, удалении стоит задержка в 1000 ms!

Создан интерфейс стратегии подсчета в хранилище (ICountingStrategy). Есть 2 реализации этого интерфейса CountByNumberStrategy (вести подсчет в количестве записей), CountBySizeStrategy (вести подсчет по объёму памяти). Здесь был применен паттерн "Strategy".

Добавление слоя(storage): добавляем в массив слоёв, подписываемся на изменение и на вытеснение (expellingListener)

При обращении к кешу он блокируется пока не будет выполнен запрос. Если мы делаем запрос в кеш, а он заблокирован другим запросом, текущий попадает в очередь. И после того как кеш разблокируется (первая команда выполнена) будет взят в обработку следующий запрос. Поэтому мы имеем возможность сделать cache.set("a", 1); cache.get("a") и быть уверенным в том, что на момент выполнения get в кеше уже будет такая пара ключ-значения, даже если у нас слой асинхронный.

Взятие с кеша: мы рекурсивно, начиная с первого слоя, пытаемся найти значение для ключа. Мы не переходим на следующий слой пока не закончим поиск на текущем (ждем выполнение promise от storage). Если значение было найдено на каком-то из слоев, мы удаляем ключ-значение из этого слоя и вставляем в первый слой.

Добавление в кеш: сначала мы пытаемся найти по ключу. Если нашли - удаляем его. Далее вставляем ключ-значение в первый слой. Если у нас это не получилось ( это может произойти если мы пытаемся вставить блок большего размера, чем вообще может вмещать слой(storage) ), то мы пытаемся вставить в следующий, после первого, слой и т.д. пока не будет вставлен или не закончатся слои (в таком случае ошибка "no suitable storage"). При добавлении мы всегда начинаем вставлять в первый слой. Если там нет месте, мы вытесняем наименее использованную пару ключ-значение на этом слое. При этом Storage выполняет функцию expellingListener. Ключ-значение, которое было вытеснено, мы пытаемся вставить в следующий слой. Если такого нет - оно удаляется.

Удаление с кеша: мы рекурсивно, начиная с первого слоя, пытаемся удалить ключ-значение. 

Как находится наименее использованная пара ключ-значение. В случае с памятью, у нас есть javascript объект. При добавлении в объект, новая пара будет последней. То есть первая пара в объекте и будет наиболее старой (а поскольку при взятии мы удаляем и вставляем, то и наименее использованной). При работе с localstorage мы из value делаем объект, в который дописываем timestamp. Сортируя по timestamp мы и получаем наиболее старую пару.

В итоге мы имеем универсальный кеш, который может состоять из неограниченного количества storage. При этом storage может быть асинхронным (get, set, remove)
Для наглядной демонстрации работы с асинхронным storage: 
если в кеше есть хоть один асихронный слой, то можно запустить тест на вставку на 500 ms и после непродолжительной работы остановить. Будет видно как некоторое время все ещё будет перемещаться, ведь в очередт остались запросы.


* какие использовались JavaScript технологии для различных частей системы
для GUI был выбран React.
для разработки библиотеки был использован ES7
для сборки webpack
для стилизации был выбран bootstrap

* на какой операционной системе велась разработка, в каком IDE
OS Windows 10.
IDE Webstorm 2017.2
node -v 7.2.0
npm -v 3.10.9

* инструкции по сборке приложения
Сборка клиентской части:
npm i
npm run dev - сборка для девелопмента
npm run build - сбрка для продакшн

Сборка библиотеки как umd модуль:
cd lib/LimitedPersistentCache
npm i
npm run dev - сборка для девелопмента
npm run build - сбрка для продакшн


